---
description: Auto coders use reflection to generate the coders at runtime
---

# Auto coders

## Auto coders

 When using **auto coders**, we are referring to both **auto encoders** and **auto decoders**.

If your JSON structure is a one to one match with your F\# type, then you can use auto coders.

### Auto decoder

Auto decoders will generate the decoder at runtime for you and still guarantee that the JSON structure is correct.

```fsharp
> let json = """{ "Id" : 0, "Name": "maxime", "Email": "mail@domain.com", "Followers": 0 }"""
> Decode.Auto.fromString<User>(json)
val it : Result<User, string> = Ok { Id = 0; Name = "maxime"; Email = "mail@domain.com"; Followers = 0 }
```

`Decode.Auto` helpers accept an optional argument `caseStrategy` that applies to keys:

* `CamelCase`, then the keys in the JSON are considered `camelCase`
* `PascalCase`, then the keys in the JSON are considered `PascalCase`
* `SnakeCase`, then the keys in the JSON are considered `snake_cases`

```fsharp
> let json = """{ "id" : 0, "name": "maxime", "email": "mail@domain.com", "followers": 0 }"""
> Decode.Auto.fromString<User>(json, caseStrategy=CamelCase)
val it : Result<User, string> = Ok { Id = 0; Name = "maxime"; Email = "mail@domain.com"; Followers = 0 }
```

### Auto encoder

Auto decoders will generate the encoder at runtime for you.

```fsharp
type User =
    { Id : int
      Name : string
      Email : string
      Followers : int }

let user =
    { Id = 0
      Name = "maxime"
      Email = "mail@domain.com"
      Followers = 0 }

let json = Encode.Auto.toString(4, user)
// {
//     "Id": 0,
//     "Name": "maxime",
//     "Email": "mail@domain.com",
//     "Followers": 0
// }
```

### Extra coders

When generating an auto coder, sometimes you will want to use a manual coder for a type nested in your domain hierarchy.

In those cases you can pass **extra coders** that will replace the default \(or missing\) coders. Use the `Extra` module to build the map for extra coders \(see example below\).

```fsharp
let myExtraCoders =
    Extra.empty
    |> Extra.withCustom MyType.Encode MyType.Decode
```

### Decoding int64, decimal or bigint

Coders for `int64`, `decimal` or `bigint` won't be automatically generated by default. If they were, the bundle size would increase significantly even if you don't intend to use these types.

If required, you can easily include them in your extra coders with the helpers in the `Extra` module:

```fsharp
let myExtraCoders =
    Extra.empty
    |> Extra.withInt64
    |> Extra.withDecimal
    |> Extra.withCustom MyType.Encode MyType.Decode
```

### Caching

To avoid having to regenerate your auto coders every time you need them, you can use the helpers with the `Cached` suffix instead \(please note in these cases you shouldn't change the value of extra parameters like `caseStrategy` or `extra`\).

The easiest way to do it is to include some helpers in your app to easily generate \(or retrieve from cache\) coders whenever you need them. For example:

```fsharp
// Note the helpers must be inlined to resolve generic parameters in Fable
let inline encoder<'T> = Encode.Auto.generateEncoderCached<'T>(caseStrategy = CamelCase, extra = myExtraCoders)
let inline decoder<'T> = Decode.Auto.generateDecoderCached<'T>(caseStrategy = CamelCase, extra = myExtraCoders)
```

Now you can easily invoke the helpers whenever you need a coder. Most of the times you can omit the generic argument as it will be inferred.

```fsharp
let demo(x : RequestType) : ResponseType =
    let requestJson = encoder x |> Encode.toString 4
    let responseJson = (* Send JSON to server and receive response *)
    Decode.unsafeFromString decoder responseJson
```

